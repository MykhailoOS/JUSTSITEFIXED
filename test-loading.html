<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading Screen Test - JustSite</title>
    <link rel="stylesheet" href="components/loading-screen.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .content {
            text-align: center;
            color: white;
            padding: 2rem;
        }
        
        .content h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .content p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 2rem;
        }
        
        .btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            margin: 0 10px;
        }
        
        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div id="loading-text">JustSite - make it simple.</div>
        <div class="loading-dots"></div>
        <div id="loading-progress">
            <div id="loading-progress-bar"></div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="content">
        <h1>üöÄ JustSite Loading Test</h1>
        <p>–ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∑–∞—Å—Ç–∞–≤–∫–∞-–∑–∞–≥—Ä—É–∑–∫–∞ —É—Å–ø–µ—à–Ω–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∞!</p>
        <p>–≠—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç —Ä–∞–±–æ—Ç—É –∑–∞—Å—Ç–∞–≤–∫–∏ —Å —à–µ–π–¥–µ—Ä–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–µ–π.</p>
        
        <div style="margin-top: 2rem;">
            <a href="landing.php" class="btn">üè† –õ–µ–Ω–¥–∏–Ω–≥</a>
            <a href="index.php" class="btn">‚ö° –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä</a>
            <a href="profile.php" class="btn">üë§ –ü—Ä–æ—Ñ–∏–ª—å</a>
            <button onclick="showLoading()" class="btn">üîÑ –ü–æ–∫–∞–∑–∞—Ç—å –∑–∞—Å—Ç–∞–≤–∫—É</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class LoadingScreen {
            constructor() {
                this.container = document.getElementById('loading-screen');
                this.progressBar = document.getElementById('loading-progress-bar');
                this.scene = null;
                this.renderer = null;
                this.camera = null;
                this.mesh = null;
                this.uniforms = null;
                this.animationId = null;
                this.progress = 0;
                
                this.init();
            }

            init() {
                this.setupThreeJS();
                this.animate();
                this.simulateLoading();
            }

            setupThreeJS() {
                // Vertex shader
                const vertexShader = `
                    void main() {
                        gl_Position = vec4( position, 1.0 );
                    }
                `;

                // Fragment shader
                const fragmentShader = `
                    #define TWO_PI 6.2831853072
                    #define PI 3.14159265359

                    precision highp float;
                    uniform vec2 resolution;
                    uniform float time;

                    void main(void) {
                        vec2 uv = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);
                        float t = time*0.05;
                        float lineWidth = 0.002;

                        vec3 color = vec3(0.0);
                        for(int j = 0; j < 3; j++){
                            for(int i=0; i < 5; i++){
                                color[j] += lineWidth*float(i*i) / abs(fract(t - 0.01*float(j)+float(i)*0.01)*5.0 - length(uv) + mod(uv.x+uv.y, 0.2));
                            }
                        }
                        
                        gl_FragColor = vec4(color[0],color[1],color[2],1.0);
                    }
                `;

                // Initialize Three.js scene
                this.camera = new THREE.Camera();
                this.camera.position.z = 1;

                this.scene = new THREE.Scene();
                const geometry = new THREE.PlaneGeometry(2, 2);

                this.uniforms = {
                    time: { type: "f", value: 1.0 },
                    resolution: { type: "v2", value: new THREE.Vector2() },
                };

                const material = new THREE.ShaderMaterial({
                    uniforms: this.uniforms,
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.scene.add(this.mesh);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.domElement.style.position = 'absolute';
                this.renderer.domElement.style.top = '0';
                this.renderer.domElement.style.left = '0';
                this.renderer.domElement.style.zIndex = '1';

                this.container.appendChild(this.renderer.domElement);

                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize(), false);
                this.onWindowResize();
            }

            onWindowResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.renderer.setSize(width, height);
                this.uniforms.resolution.value.x = this.renderer.domElement.width;
                this.uniforms.resolution.value.y = this.renderer.domElement.height;
            }

            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());
                this.uniforms.time.value += 0.05;
                this.renderer.render(this.scene, this.camera);
            }

            simulateLoading() {
                const duration = 2500; // 2.5 seconds
                const interval = 30; // Update every 30ms for smoother animation
                const increment = 100 / (duration / interval);

                const loadingInterval = setInterval(() => {
                    this.progress += increment;
                    this.progressBar.style.width = Math.min(this.progress, 100) + '%';

                    // Add some randomness to make it feel more natural
                    if (Math.random() < 0.1 && this.progress < 90) {
                        this.progress += increment * 2;
                    }

                    if (this.progress >= 100) {
                        clearInterval(loadingInterval);
                        setTimeout(() => {
                            this.hide();
                        }, 300);
                    }
                }, interval);
            }

            hide() {
                // Add fade out effect with scale
                this.container.style.opacity = '0';
                this.container.style.transform = 'scale(1.1)';
                this.container.style.transition = 'opacity 0.6s ease-out, transform 0.6s ease-out';
                
                setTimeout(() => {
                    this.container.style.display = 'none';
                    this.cleanup();
                }, 600);
            }

            cleanup() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                
                if (this.renderer) {
                    this.renderer.dispose();
                }
                
                window.removeEventListener('resize', () => this.onWindowResize());
            }
        }

        // Initialize loading screen when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new LoadingScreen();
        });

        // Function to show loading screen again
        function showLoading() {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.style.display = 'flex';
            loadingScreen.style.opacity = '1';
            loadingScreen.style.transform = 'scale(1)';
            
            // Reset progress bar
            const progressBar = document.getElementById('loading-progress-bar');
            progressBar.style.width = '0%';
            
            // Start new loading animation
            new LoadingScreen();
        }
    </script>
</body>
</html>
